; ref)
; exeアイコンの取り出し http://lhsp.s206.xrea.com/hsp_file.html
; オブジェクトの活性/非活性 http://lhsp.s206.xrea.com/hsp_object2.html
; マウスカーソルの取得 http://antares.cn/hsp/sample/index.html#mouse
; elseifのスマートな書き方 https://kouza.hamuinu.com/wiki_page/HSP%E8%AC%9B%E5%BA%A7/HSP%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%B7%A8/%E7%AC%AC10%E7%AB%A0%20%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90
; 管理者権限の獲得 http://hsptv.sakura.ne.jp/play/pforum.php?mode=pastwch&num=72960#73405
; タスクトレイへの格納 http://hsp.tv/play/pforum.php?mode=pastwch&num=1594#1760
; 領域外のマウスイベント取得 

; API読み込み
#uselib "gdi32" 
#cfunc CreateEllipticRgn "CreateEllipticRgn" int, int, int, int
#uselib "user32"
#func SetWindowRgn "SetWindowRgn" int, int, int
#func DrawIcon "DrawIcon" sptr, sptr, sptr, sptr
#func DestroyIcon "DestroyIcon" sptr
#func EnableWindow "EnableWindow" int, int
#cfunc GetAsyncKeyState "GetAsyncKeyState" int
#uselib "shell32"
#func SHGetFileInfo "SHGetFileInfo" sptr, sptr, sptr, sptr, sptr
#func ShellExecuteEx "ShellExecuteEx" sptr
#func ExtractIconEx "ExtractIconExA" int, int, int, int, int
#func Shell_NotifyIcon "Shell_NotifyIcon" int, int
#uselib "kernel32.dll"
#func GetModuleFileNameA "GetModuleFileNameA" int, int, int

; 関数の定義
#module
#defcfunc getMx
	prmx=ginfo_sizex: frameW=(prmx-320)/2 ;補正値の計算
	prmx=ginfo_wx1:   left=prmx+frameW    ;原点のスクリーン座標
	prmx=ginfo_mx:    mx=prmx-left        ;スクリーン座標→ウィンドウ座標
	return mx
#defcfunc getMy
	prmx=ginfo_sizex:    prmy=ginfo_sizey
	frameW=(prmx-320)/2: titleH=prmy-320-frameW ;補正値の計算
	prmy=ginfo_wy1:      top=prmy+titleH        ;原点のスクリーン座標
	prmy=ginfo_my:       my=prmy-top            ;スクリーン座標→ウィンドウ座標
	return my
#global

#module
#defcfunc isExecutable str s
	i = 1
	t = s
	if strmid(t, -1, 4) = ".exe" :i = 0
	return i
#defcfunc isAbsolutePath str s
	; rel) https://dobon.net/vb/dotnet/file/isabsolutepath.html
	; パス名の先頭が「\\」「[A-Za-z]:\\」(←これは割り切り判定)「\」なら絶対パス
	i = 0
	t = s
	if strmid(t, 0, 2) == "\\\\" :i = 1
	if strmid(t, 1, 2) == ":\\"  :i = 1
	if strmid(t, 0, 1) == "\\"   :i = 1
	return i
#defcfunc getpathEx str s
	t = s
	i1 = instr(t, 0, " ")
	i2 = instr(t, 0, "\"")
	i3 = instr(t, i2, "\"")
	if i2 == 0 {
		t = strmid(t, 0, i3)
	} else : if i1 > 0 {
		t = strmid(t, 0, i1-1)
	}
	t = getpath(t, 32)
	return t
#defcfunc getTypeKey str s
	i = 0
	if s = "exe"  :i = 0
	if s = "file" :i = 1
	if s = "dir"  :i = 2
	if s = "uac"  :i = 3
	return i
#defcfunc getTypeValue int j
	t = ""
	if j = 0 :t = "exe"
	if j = 1 :t = "file"
	if j = 2 :t = "dir"
	if j = 3 :t = "uac"
	return t
#global

;-------------------------------------------------------------------------------
;          ;
           ; 初期化処理
;          ;
;-------------------------------------------------------------------------------

	; どのウィンドウであれ、閉じるボタンが押された時を検出
	onexit gosub *onclose
	oncstat = 0

	; タスクトレイのアイコンクリック
	oncmd gosub *clicktasktray, $1400

	curdir = dir_cur

	; アイテム編集画面の作成
	screen 3, 320, 240, 2
	cls 0

	objmode 2, 1
	color 0, 0, 0
	font msgothic, 16

	pos 16, 16
	font msgothic, 16
	mes "名前"
	pos 56, 16
	font msgothic, 12
	editName = ""
	input editName, 248, 16, 32
	idEditName = stat
	pos 16, 40
	font msgothic, 16
	mes "場所"
	pos 56, 40
	font msgothic, 12
	editPath = ""
	input editPath, 208, 16, 1024
	idEditPath = stat
	pos 272, 38
	objsize 32, 20
	button gosub "参照", *callLocation
	idButtonEditPath = stat
	pos 16, 64
	font msgothic, 16
	mes "Icon"
	pos 56, 64
	font msgothic, 12
	editIcon = ""
	input editIcon, 208, 16, 1024
	idEditIcon = stat
	sendmsg objinfo(idEditIcon, 2), $CF, 1 ; 編集不可
	pos 272, 62
	objsize 32, 20
	button gosub "参照", *callIconLocation
	pos 16, 88
	font msgothic, 16
	mes "種別"
	pos 56, 86
	font msgothic, 12
	editType = 0
	objsize 120, 20
	combox editType, 40, "実行形式\nファイル\nサブメニュー\n管理者権限"
	idEditType = stat

	pos 96, 112
	objsize 64, 32
	font msgothic, 16
	button gosub "登録", *registItem

;-------------------------------------------------------------------------------
;              ;
*tasktraylabel ; タスクトレイ格納・復帰
;              ;
;-------------------------------------------------------------------------------

	curdat = "root.dat"
	parentdat = ""

	; タスクトレイ格納
	gsel 0, -1
	sdim myNameIs, 3200
	GetModuleFileNameA hm, varptr(myNameIs), 3200
	myiconB = 0: myiconS = 0
	ExtractIconEx varptr(myNameIs), 0, varptr(myiconB), varptr(myiconS), 1
	hIcon = myiconS
	dim IconData, 22
	IconData = 88, hwnd, 1 , $0003, $1400, hIcon
	Shell_NotifyIcon NIM_ADD, varptr(IconData)

	; ロッカージェスチャー入力待ち
	MouseLock = 0
	repeat
		/*
			https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
			VK_LBUTTON 0x01 Left mouse button
			VK_RBUTTON 0x02 Right mouse button
			VK_MBUTTON 0x04 Middle mouse button (three-button mouse)
			VK_XBUTTON1 0x05 X1 mouse button
			VK_XBUTTON2 0x06 X2 mouse button
		*/
		; ロッカージェスチャーRL
		locker1st = GetAsyncKeyState(2)
		locker2nd = GetAsyncKeyState(1)
		; ロッカージェスチャー
		if ( MouseLock == 0 ) {
			if ( locker1st != 0 )&( locker2nd == 0 ) : MouseLock = 1
		} else : if ( MouseLock == 1 ) {
			if ( locker1st != 0 )&( locker2nd != 0 ) : MouseLock = 2
			if ( locker1st == 0 )&( locker2nd == 0 ) : MouseLock = 0
		} else : if ( MouseLock == 2 ) {
			if ( locker1st == 0 )&( locker2nd == 0 ) {
				MouseLock = 0
				break
			}
		}
		wait 1
	loop

	; タスクトレイ復帰
	dim IconData, 22
	IconData = 88, hwnd, 1, $2
	Shell_NotifyIcon $2, varptr(IconData)

*initwindow
	; 円形ウィンドウ作成
	x = ginfo_mx - 160
	y = ginfo_my - 160
	if x < 0 :x = 0
	if x > (ginfo_dispx - 320) :x = ginfo_dispx - 320
	if y < 0 :y = 0
	if y > (ginfo_dispy - 320) :y = ginfo_dispy - 320
	bgscr 0, 320, 320, 0, x, y
	hRgn = CreateEllipticRgn (0, 0, 320, 320)
	SetWindowRgn hwnd, hRgn, 1
	cls 0

	buffer 1, 512, 32, 0
	gsel 1
	cls 0
	gsel 0

	dim SHFILEINFO, 88

	gosub *getdat

;-------------------------------------------------------------------------------
;          ;
*mainlabel ; メイン
;          ;
;-------------------------------------------------------------------------------

	gsel 0, 2

	changedat = 0
	puttasktray = 0
	repeat
		gosub *drawing
		gosub *event
		wait 1
		if changedat == 1 :break
		if puttasktray == 1 :break
	loop

	if puttasktray == 1 :goto *tasktraylabel
	goto *initwindow

;--------------------+
; ランチャー表示関係 |
;--------------------+

*drawing
	redraw 2
	color 255, 255, 255 :boxf 0, 0, 320, 320

	division = itemLen
	if division < 16 :division++

	; マウス位置の取得
	x = getMx()
	y = getMy()
	if (( x - 160 ) * ( x - 160 ) + ( y - 160 ) * ( y - 160 )) <= 25600 {
		if ( 120 <= x )&( x < 200 )&( 120 <= y )&( y < 200 ) {
			; 中心
			i = -1
		} else {
			; 各アイテム
			th = atan(y - 160, x - 160)
			th += M_PI / 2
			if th < 0 :th += 2 * M_PI

			i = int(th * division / (2 * M_PI))
		}
	} else {
		; 画面外
		i = -2
	}

	repeat division
		; 描画
		radLine = deg2rad(360 * cnt / division - 90)
		radIco = deg2rad(360 * cnt / division - 90 + (180 / division))
		x = 160 + int(160.0 * cos(radLine))
		y = 160 + int(160.0 * sin(radLine))
		color 0, 0, 0
		line 160, 160, x, y

		if cnt < itemLen {
			; アイコン描画
			x = 144 + int(120.0 * cos(radIco))
			y = 144 + int(120.0 * sin(radIco))
			pos x, y
			gcopy 1, 32 * cnt, 0, 32, 32
		} else {
			; 新規
		}
	loop

	color 0, 0, 0 :boxf 119, 119, 201, 201
	color 255, 255, 255 :boxf 120, 120, 200, 200
	if i == -1 {
		color 0, 0, 0 :font msgothic, 16
		if strlen(parentdat) > 0 {
			pos 128, 152
			mes "一つ上へ"
		} else {
			pos 144, 152
			mes "村茶"
		}
	} else : if ( 0 <= i )&( i < itemLen ) {
		color 0, 0, 0 :font msgothic, 16
		repeat 5
			if strlen(itemDispName(i, cnt)) > 0 :dnt = cnt
		loop
		dnt++
		repeat dnt
			namelen = strlen(itemDispName(i, cnt))
			pos 4 * ( 10 - namelen ) + 120, ( -8 * dnt ) + ( 16 * cnt ) + 160
			mes itemDispName(i, cnt)
		loop
	} else : if ( i == itemLen ) {
		color 0, 0, 0 :font msgothic, 16 :pos 144, 152
		mes "新規"
	} else {
		; 画面外
	}

	redraw 1
	return

*event
	if ( i >= 0 ) {
		stick ev, 0, 1
		if ev & 256 {
			if i < itemLen {
				if itemType(i) == "exe" {
					if isAbsolutePath(itemPath(i)) :chdir getpathEx(itemPath(i))
					exec itemPath(i)
					puttasktray = 1
				} else : if itemType(i) == "file" {
					exec itemPath(i), 16
					puttasktray = 1
				} else : if itemType(i) == "dir" {
					changedat = 1
					curdat = itemPath(i)
				} else : if itemType(i) == "uac" {
					if isAbsolutePath(itemPath(i)) :chdir getpathEx(itemPath(i))
					str_executefile = itemPath(i)
					str_performmode = "runas"

					dim tag_shell_excute_info, 15
					tag_shell_excute_info = 4*15, 0, 0, varptr(str_performmode), varptr(str_executefile), 0, 0, 5
					ShellExecuteEx varptr(tag_shell_excute_info)
					puttasktray = 1
				}
			} else {
				dialog "", 16
				if stat == 1 {
					argIndex = -1 ; 新規
					argName = ""
					argPath = refstr
					argIcon = refstr
					argType = isExecutable(refstr)
					gosub *itemedit
				}
			}
		} else : if ev & 512 {
			if i < itemLen {
				argIndex = i ; 編集
				argName = itemName(i)
				argPath = itemPath(i)
				argIcon = itemIcon(i)
				argType = getTypeKey(itemType(i))
				gosub *itemedit
			} else {
				puttasktray = 1
			}
		} else : if ev & 128 {
			end
		}
	} else : if ( i == -1 ) {
		stick ev, 0, 1
		if ev & 256 {
			if strlen(parentdat) > 0 {
				changedat = 1
				curdat = parentdat
			}
		}
	}
	return

;------------------+
; タスクトレイ関係 |
;------------------+
*clicktasktray
	if (ginfo_act < 0)&(lparam == $00000201) {
		dialog "終了しますか？", 2
		if stat == 6 :end
	}
	return

;------------------+
; アイテム編集画面 |
;------------------+
*itemedit
	gsel 0
	EnableWindow hwnd, 0 ; 自ウィンドウを無効にする。

	gsel 3, -1
	width , , ginfo_mx - 160, ginfo_my - 120
	gsel 3, 2
	objprm idEditName, argName
	objprm idEditPath, argPath
	objprm idEditIcon, argIcon
	objprm idEditType, argType

	color 255, 255, 255
	boxf 56, 112, 88, 152
	if argIcon != "" {
		gosub *repaintIcon
	}

	repeat
		getkey ev, 27
		if (ev == 1)|(oncstat == 1) :break

		if EditType == 2 { ; サブメニュー
			objenable idEditPath, 0
			objenable idButtonEditPath, 0
			if (argIndex == -1)|(itemType(i) != "dir") :objprm idEditPath, editName + ".dat"
		} else {
			objenable idEditPath, 1
			objenable idButtonEditPath, 1
		}
		wait 5
	loop
	oncstat = 0

	gsel 3, -1
	gsel 0, 2
	EnableWindow hwnd, 1
	return

*callLocation
	dialog "", 16
	if stat = 1 {
		objprm idEditPath, refstr
		objprm idEditType, isExecutable(refstr)
	}
	return

*callIconLocation
	dialog "", 16
	if stat = 1 {
		argIcon = refstr
		objprm idEditIcon, argIcon

		color 255, 255, 255
		boxf 56, 112, 88, 152
		gosub *repaintIcon
		redraw 1
	}
	return

*repaintIcon
	SHGetFileInfo argIcon, 0, varptr(SHFILEINFO), $160, $500
	x = 56
	y = 112
	DrawIcon hdc, x, y, SHFILEINFO.0
	DestroyIcon SHFILEINFO.0

	return

*registItem
	if EditType == 2 { ; サブメニューであり、名前が重複している場合は登録しない
		chdir curdir
		exist "data\\" + EditPath
		if strsize >= 0 {
			dialog "この名前のサブメニューは登録済みです。\n同じものを呼び出しますか？", 3
			if stat == 7 :return
		}
	}
	gosub *writedat
	gosub *getdat
	oncstat = 1
	return

;-------------------+
; Dat情報の読み込み |
;-------------------+
*getdat
	notesel nt
	chdir curdir
	noteload "data\\" + curdat

	gsel 1
	cls 0

	itemLen = 0
	repeat noteinfo(0)
		noteget s, cnt
		if s == "[item]" :itemLen++
		if strmid(s, 0, 7) == "parent=" : parentdat = strmid(s, 7, 1024)
	loop

	sdim itemName, 32, itemLen
	sdim itemDispName, 10, itemLen, 5
	sdim itemPath, 1024, itemLen
	sdim itemIcon, 1024, itemLen
	sdim itemType, 8, itemLen

	len = -1
	repeat noteinfo(0)
		noteget s, cnt
		t = strmid(s, 0, 5)
		if s == "[item]" :len++
		if t == "name=" :itemName(len) = strmid(s, 5, 32)
		if t == "path=" :itemPath(len) = strmid(s, 5, 1024)
		if t == "icon=" {
			; アイコン取得
			itemIcon(len) = strmid(s, 5, 1024)
			SHGetFileInfo itemIcon(len), 0, varptr(SHFILEINFO), $160, $500
			x = 32 * len
			y = 0
			DrawIcon hdc, x, y, SHFILEINFO.0
			DestroyIcon SHFILEINFO.0
		}
		if t == "type=" :itemType(len) = strmid(s, 5, 8)
	loop

	len++
	itemName(len) = ""
	itemPath(len) = ""
	itemType(len) = ""

	repeat len
		cursor = 0 :column = 0
		dnt = cnt
		repeat strlen(itemName(dnt))
			b = peek(itemName(dnt), cnt)
			if ( cursor == 11 )|(( cursor == 10 )&((( 129 <= b )&( b <= 159 ))|(( 224 <= b )|( b <= 252 )))) {
				column++ :cursor = 0
			}
			poke itemDispName(dnt, column), cursor, b
			cursor++
		loop
	loop

	gsel 0
	return

*writedat
	if argIndex == -1 {
		noteadd "[item]", -1, 0
		noteadd "name=" + editName, -1, 0
		noteadd "path=" + editPath, -1, 0
		noteadd "icon=" + editIcon, -1, 0
		noteadd "type=" + getTypeValue(editType), -1, 0
	} else {
		len = -1
		repeat noteinfo(0)
			noteget s, cnt
			if s == "[item]" :len++
			if len == argIndex {
				t = strmid(s, 0, 5)
				if t == "name=" :noteadd "name=" + editName, cnt, 1
				if t == "path=" :noteadd "path=" + editPath, cnt, 1
				if t == "icon=" :noteadd "icon=" + editIcon, cnt, 1
				if t == "type=" :noteadd "type=" + getTypeValue(editType), cnt, 1
			}
		loop
	}

	chdir curdir
	notesave "data\\" + curdat

	if (argIndex == -1)&(editType==2) {
		s = "parent=" + curdat
		bsave "data\\" + editPath, s
	}

	return



*onclose
	if ginfo_act = 0 :end
	oncstat = 1
	return

stop