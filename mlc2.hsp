;#makeopt icon_rsrc "mlc2.ico"
#packopt name "mlc2.exe"
#packopt hide 1

; ref)
; アイコンの取り出し http://lhsp.s206.xrea.com/hsp_file.html (.lnkが表示可能)
; アイコンの取り出し http://hsp.tv/play/pforum.php?mode=pastwch&num=85798 (.exe/.dll内の複数アイコンが表示可能)
; オブジェクトの活性/非活性 http://lhsp.s206.xrea.com/hsp_object2.html
; マウスカーソルの取得 http://antares.cn/hsp/sample/index.html#mouse
; elseifのスマートな書き方 https://kouza.hamuinu.com/wiki_page/HSP%E8%AC%9B%E5%BA%A7/HSP%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%B7%A8/%E7%AC%AC10%E7%AB%A0%20%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90
; 管理者権限の獲得 http://hsptv.sakura.ne.jp/play/pforum.php?mode=pastwch&num=72960#73405
; タスクトレイへの格納 http://hsp.tv/play/pforum.php?mode=pastwch&num=1594#1760
; 領域外のマウスイベント取得 http://hsp.tv/play/pforum.php?mode=pastwch&num=76709#76718
; 簡易的な多重起動の防止 http://chokuto.ifdef.jp/advanced/singleton1.html

; スクリーンID
; 0 : メイン画面
; 1 : メイン画面におけるアイコン画像バッファ
; 2 : スプラッシュウィンドウ
; 3 : アイテム編集画面
; 4 : 設定画面
; 5 : アイテム編集におけるアイコン画像バッファ
; 6 : アイテム複写におけるアイコン画像バッファ

; API読み込み
#uselib "gdi32" 
#cfunc CreateEllipticRgn "CreateEllipticRgn" int, int, int, int
#uselib "user32"
#func SetWindowRgn "SetWindowRgn" int, int, int
#func EnableWindow "EnableWindow" int, int
#cfunc GetAsyncKeyState "GetAsyncKeyState" int
#uselib "shell32"
#func ShellExecuteEx "ShellExecuteEx" sptr
#func DragAcceptFiles "DragAcceptFiles" int,int
#func DragQueryFile   "DragQueryFileA"  int,int,int,int
#func DragQueryPoint  "DragQueryPoint"  int,int
#func DragFinish      "DragFinish"      int
#func ExtractIconEx "ExtractIconExA" int, int, int, int, int
#func Shell_NotifyIcon "Shell_NotifyIcon" int, int
#uselib "kernel32.dll"
#func GetModuleFileNameA "GetModuleFileNameA" int, int, int

#include "mod_fontdlg.as"
#include "hspext.as"

; 関数の定義
#module
#defcfunc getMx
	prmx=ginfo_sizex: frameW=(prmx-320)/2 ;補正値の計算
	prmx=ginfo_wx1:   left=prmx+frameW    ;原点のスクリーン座標
	prmx=ginfo_mx:    mx=prmx-left        ;スクリーン座標→ウィンドウ座標
	return mx
#defcfunc getMy
	prmx=ginfo_sizex:    prmy=ginfo_sizey
	frameW=(prmx-320)/2: titleH=prmy-320-frameW ;補正値の計算
	prmy=ginfo_wy1:      top=prmy+titleH        ;原点のスクリーン座標
	prmy=ginfo_my:       my=prmy-top            ;スクリーン座標→ウィンドウ座標
	return my
#global

#module
#defcfunc isNotExecutable str s
	i = 1
	t = getpath( s, 18 )
	if t == ".exe" :i = 0
	return i
#defcfunc isExeOrDll str s
	i = 0
	t = getpath( s, 18 )
	if ( t == ".exe" )|( t == ".dll" ) :i = 1
	return i
#defcfunc isAbsolutePath str s
	; rel) https://dobon.net/vb/dotnet/file/isabsolutepath.html
	; パス名の先頭が「\\」「[A-Za-z]:\\」(←これは割り切り判定)「\」なら絶対パス
	i = 0
	t = s
	if strmid(t, 0, 2) == "\\\\" :i = 1
	if strmid(t, 1, 2) == ":\\"  :i = 1
	if strmid(t, 0, 1) == "\\"   :i = 1
	return i
#defcfunc getpathEx str s, int f
	t = s
	i1 = instr(t, 0, " ")
	i2 = instr(t, 0, "\"")
	i3 = instr(t, i2 + 1, "\"")
	if i2 == 0 {
		t = strmid(t, 1, i3)
	} else : if i1 > 0 {
		exist t
		if strsize == -1 {
			t = strmid(t, 0, i1)
		}
	}
	if f == 0 {
		; フォルダを返す
		t = getpath(t, 32)
	}
	return t
#defcfunc getTypeKey str s
	i = 0
	if s == "exe"  :i = 0
	if s == "file" :i = 1
	if s == "fold" :i = 2
	if s == "dir"  :i = 3
	if s == "uac"  :i = 4
	return i
#defcfunc getTypeValue int j
	t = ""
	if j == 0 :t = "exe"
	if j == 1 :t = "file"
	if j == 2 :t = "fold"
	if j == 3 :t = "dir"
	if j == 4 :t = "uac"
	return t
#defcfunc getLockerKey int j
	i = j - 1
	if i > 1 :i -= 1
	return i
#defcfunc getLockerValue int j
	i = j + 1
	if i > 2 :i += 1
	return i
#deffunc setColor int j
	color j >> 16, ( j >> 8 ) & 255, j & 255
	return
#global

#module
#uselib "shell32"
#func ExtractIcon "ExtractIconA" int,sptr,int
#func SHGetFileInfo "SHGetFileInfo" sptr, sptr, sptr, sptr, sptr
#uselib "user32"
#func DrawIcon "DrawIcon" sptr, sptr, sptr, sptr
#func DestroyIcon "DestroyIcon" sptr
dim SHFILEINFO, 88
#deffunc drawIcon2Hdc str s, int x, int y, int j
	if ( isExeOrDll(s) ) {
		ExtractIcon	 hInstance, s, j
		HIcon = stat
	} else {
		SHGetFileInfo s, 0, varptr(SHFILEINFO), $160, $500
		HIcon = SHFILEINFO.0
	}
	DrawIcon hdc, x, y, HIcon
	DestroyIcon HIcon
	return
#defcfunc getIconIndexMax str s
	i = 1
	if ( isExeOrDll(s) ) {
		ExtractIcon hInstance, s, -1
		i = stat
	}
	return i
#global

#module
#uselib "kernel32.dll"
#func  CloseHandle  "CloseHandle"  int
#cfunc CreateMutex  "CreateMutexA" int, int, sptr
#cfunc GetLastError "GetLastError"
#define ERROR_ALREADY_EXISTS    183

#define MUTEX_NAME  "Mulancha_2"

; このアプリケーションがすでに起動されているかどうかを取得する関数
#defcfunc AlreadyAppRunning

if (hMutex == 0) {
	; 名前付きミューテックスオブジェクトの作成
	hMutex = CreateMutex(0, 0, MUTEX_NAME)

	; オブジェクトがすでに作成されていたかどうかの判別
	if (GetLastError() == ERROR_ALREADY_EXISTS) {
		; すでに同じ名前のオブジェクトが存在する
		alreadyRunning = 1
	} else {
		; オブジェクトが新しく作成された
		alreadyRunning = 0
	}
}
return alreadyRunning

; クリーンアップ処理（終了時に自動実行）
#deffunc CleanupAppRunChecker onexit
if (hMutex != 0) {
	; ミューテックスオブジェクトハンドルのクローズ
	CloseHandle hMutex
	hMutex = 0
}
return
#global

;-------------------------------------------------------------------------------
;          ;
           ; 初期化処理
;          ;
;-------------------------------------------------------------------------------

	; アプリケーションの実行チェック
	if (AlreadyAppRunning()) {
		dialog "Mulancha はすでに起動されています。"
		end
	}

	notesel nt
	version = "2 RC2"

	; どのウィンドウであれ、閉じるボタンが押された時を検出
	onexit gosub *onclose
	oncstat = 0
	ondstat = 0
	onestat = 0
	reloaddatbutnotmove = 0
	sdim ondfname, 1024

	; タスクトレイのアイコンクリック
	oncmd gosub *clicktasktray, $1400

	curdir = dir_cur

	clickitem = 0

	; 複写領域
	copymode = 0

	; ini読み込み
	sdim iniFiler, 1024
	sdim iniFont, 128

	noteload "mlc2.ini"
	noteget s, 1
	iniLocker1 = int(strmid(s, 8, 1))
	noteget s, 2
	iniLocker2 = int(strmid(s, 8, 1))
	noteget s, 3
	iniFiler = strmid(s, 6, 1024)
	exist( iniFiler )
	if strsize == -1 :iniFiler = "explorer"
	noteget s, 4
	iniFont = strmid(s, 5, 128)
	if strlen( iniFont ) == 0 :iniFont = msgothic
	noteget s, 5
	iniFGColor = int("$" + strmid(s, 9, 6))
	noteget s, 6
	iniBGColor = int("$" + strmid(s, 9, 6))
	noteget s, 7
	iniSplash = int(strmid(s, 7, 1))

	if iniSplash == 1 {
		bgscr 2, 320, 160, 2, ( ginfo_dispx - 320 ) / 2 , ( ginfo_dispy - 80 ) / 2
		cls 0
		pos 176, 16
		picload "mlc2.png", 1
		color 0, 0, 0
		font iniFont, 32
		pos 16, 112 :mes "Mulancha " + version
		gsel 2, 2
		repeat 100
			wait 1
			stick ev
			if ev != 0 :break
		loop
	}

	gosub *createEditDialog
	gosub *createSettingDialog

	if iniSplash == 1 {
		gsel 2, -1
	}

;-------------------------------------------------------------------------------
;              ;
*tasktraylabel ; タスクトレイ格納・復帰
;              ;
;-------------------------------------------------------------------------------

	curdat = "root.dat"
	parentdat = ""

	; タスクトレイ格納
	gsel 0, -1
	sdim myNameIs, 3200
	GetModuleFileNameA hm, varptr(myNameIs), 3200
	myiconB = 0: myiconS = 0
	ExtractIconEx varptr(myNameIs), 0, varptr(myiconB), varptr(myiconS), 1
	hIcon = myiconS
	dim IconData, 22
	IconData = 88, hwnd, 1 , $0003, $1400, hIcon
	Shell_NotifyIcon NIM_ADD, varptr(IconData)

	; アイテムをクリックして格納したなら、それを実行する
	if clickitem == 1 {
		isExist = 1
		if itemType(i) == "fold" {
			s = itemPath(i) ; フォルダの場合のみ半角空白を許容
		} else {
			s = getpathEx( itemPath(i), 1 )
		}

		if isAbsolutePath( s ) {
			; 存在チェック
			if itemType(i) == "fold" {
				chdir getpath( s, 32 )
				if strlen( getpath( s, 9 )) > 0  {
					dirlist temp, getpath( s, 9 ), 5
					if stat == 0 :isExist = 0
				}
			} else {
				exist s
				if strsize == -1 :isExist = 0
			}
		}
		if isExist == 0 {
			; アイテムが存在しない場合の処理(絶対パスのみ判定可能)
			dialog itemName(i) + "は存在しません。\n" + itemPath(i) + "が存在するかご確認下さい。", 1
		} else {
			if itemType(i) == "exe" {
				if strlen(itemWorkDir(i)) > 0 {
					chdir itemWorkDir(i)
				} else {
					if isAbsolutePath(itemPath(i)) :chdir getpathEx(itemPath(i), 0)
				}
				exec itemPath(i)
			} else : if itemType(i) == "file" {
				exec itemPath(i), 16
			} else : if itemType(i) == "fold" {
				if instr( itemPath(i), 0, " " ) >= 0 {
					exec iniFiler + " \"" + itemPath(i) + "\""
				} else {
					exec iniFiler + " " + itemPath(i)
				}
			} else : if itemType(i) == "uac" {
				if isAbsolutePath(itemPath(i)) :chdir getpathEx(itemPath(i), 0)
				str_executefile = itemPath(i)
				str_performmode = "runas"

				dim tag_shell_excute_info, 15
				tag_shell_excute_info = 4*15, 0, 0, varptr(str_performmode), varptr(str_executefile), 0, 0, 5
				ShellExecuteEx varptr(tag_shell_excute_info)
			}
		}
	}

	; ロッカージェスチャー入力待ち
	MouseLock = 0
	repeat
		/*
			https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
			VK_LBUTTON 0x01 Left mouse button
			VK_RBUTTON 0x02 Right mouse button
			VK_MBUTTON 0x04 Middle mouse button (three-button mouse)
			VK_XBUTTON1 0x05 X1 mouse button
			VK_XBUTTON2 0x06 X2 mouse button
		*/
		; ロッカージェスチャーRL
		locker1st = GetAsyncKeyState(iniLocker1)
		locker2nd = GetAsyncKeyState(iniLocker2)
		; ロッカージェスチャー
		if ( MouseLock == 0 ) {
			if ( locker1st != 0 )&( locker2nd == 0 ) : MouseLock = 1
		} else : if ( MouseLock == 1 ) {
			if ( locker1st != 0 )&( locker2nd != 0 ) : MouseLock = 2
			if ( locker1st == 0 )&( locker2nd == 0 ) : MouseLock = 0
		} else : if ( MouseLock == 2 ) {
			if ( locker1st == 0 )&( locker2nd == 0 ) {
				MouseLock = 0
				break
			}
		}
		wait 1
	loop

	; タスクトレイ復帰
	dim IconData, 22
	IconData = 88, hwnd, 1, $2
	Shell_NotifyIcon $2, varptr(IconData)

*initwindow
	; 円形ウィンドウ作成
	if reloaddatbutnotmove == 0 {
		x = ginfo_mx - 160
		y = ginfo_my - 160
		if x < 0 :x = 0
		if x > (ginfo_dispx - 320) :x = ginfo_dispx - 320
		if y < 0 :y = 0
		if y > (ginfo_dispy - 320) :y = ginfo_dispy - 320
		bgscr 0, 320, 320, 0, x, y
		hRgn = CreateEllipticRgn (0, 0, 320, 320)
		SetWindowRgn hwnd, hRgn, 1
	}

	setColor iniBGColor
	boxf 0, 0, 320, 320

	gosub *getdat

	oncmd gosub *onDropFiles, 0x0233
	if itemLen < 16 {
		DragAcceptFiles hwnd, 1
	} else {
		; アイテム数が最大の場合はD&Dを受け付けない
		DragAcceptFiles hwnd, 0
	}

;-------------------------------------------------------------------------------
;          ;
*mainlabel ; メイン
;          ;
;-------------------------------------------------------------------------------

	gsel 0, 2

	reloaddat = 0
	reloaddatbutnotmove = 0
	puttasktray = 0
	clickitem = 0

	onestat = -2

	repeat
		gosub *drawing
		gosub *event
		wait 1
		if ( reloaddat | puttasktray | clickitem ) == 1 :break
	loop
	ondstat = 0

	if ( puttasktray | clickitem ) == 1 :goto *tasktraylabel

	goto *initwindow

;--------------------+
; ランチャー表示関係 |
;--------------------+

*drawing
	redraw 2
	setColor iniFGColor :boxf 0, 0, 320, 320
	setColor iniBGColor :circle 1, 1, 318, 318, 1

	division = itemLen
	if division < 16 :division++

	; マウス位置の取得
	x = getMx()
	y = getMy()
	if (( x - 160 ) * ( x - 160 ) + ( y - 160 ) * ( y - 160 )) <= 25600 {
		if ( 120 <= x )&( x < 200 )&( 120 <= y )&( y < 200 ) {
			; 中心
			i = -1
		} else {
			; 各アイテム
			th = atan(y - 160.0, x - 160.0)
			th += M_PI / 2.0
			if th < 0 :th += 2.0 * M_PI

			i = int(th * division / (2.0 * M_PI))
		}
	} else {
		; 画面外
		i = -2
	}

	repeat division
		; 描画
		radLine = deg2rad(360 * cnt / division - 90)
		radIco = deg2rad(360 * cnt / division - 90 + (180 / division))

		if cnt < itemLen {
			; アイコン描画
			x = 144 + int(120.0 * cos(radIco))
			y = 144 + int(120.0 * sin(radIco))
			pos x, y
			gcopy 1, 32 * cnt, 0, 32, 32
		} else {
			; 新規
		}

		x = 160 + int(160.0 * cos(radLine))
		y = 160 + int(160.0 * sin(radLine))
		setColor iniFGColor
		line 160, 160, x, y
	loop

	setColor iniFGColor :boxf 119, 119, 201, 201
	setColor iniBGColor :boxf 120, 120, 200, 200
	if i == -1 {
		setColor iniFGColor :font iniFont, 16
		if strlen(parentdat) > 0 {
			pos 128, 152
			mes "一つ上へ"
		} else {
			pos 144, 152
			mes "設定"
		}
	} else : if ( 0 <= i )&( i < itemLen ) {
		setColor iniFGColor :font iniFont, 16
		repeat 5
			if strlen(itemDispName(i, cnt)) > 0 :dnt = cnt
		loop
		dnt++
		repeat dnt
			namelen = strlen(itemDispName(i, cnt))
			pos 4 * ( 10 - namelen ) + 120, ( -8 * dnt ) + ( 16 * cnt ) + 160
			mes itemDispName(i, cnt)
		loop
	} else : if ( i == itemLen ) {
		setColor iniFGColor :font iniFont, 16 :pos 144, 152
		mes "新規"
	} else {
		; 画面外
	}

	redraw 1
	return

*event
	if ( ondstat == 1 ) {
		argIndex = -1 ; 新規
		argName = getpath( ondfname, 9 )
		argPath = ondfname
		argIcon = ondfname
		dirlist temp, ondfname, 5
		if ( stat == 1 ) {
			argType = getTypeKey( "fold" )
			argWdir = ""
		} else {
			argType = isNotExecutable( ondfname )
			if argType == 0 {
				argWdir = getpathEx( ondfname, 0 )
			} else {
				argWdir = ""
			}
		}
		editIconIndex = 0
		gosub *itemedit
		reloaddat = 1
	} else : if ( i >= 0 ) {
		stick ev, 0, 1
		if ev & 256 {
			onestat = i
		} else : if ev & 512 {
			if i < itemLen {
				argIndex = i ; 編集
				argName = itemName(i)
				argPath = itemPath(i)
				argIcon = itemIcon(i)
				argType = getTypeKey(itemType(i))
				argWdir = itemWorkDir(i)
				editIconIndex = itemIconIndex(i)
				gosub *itemedit
				reloaddat = 1
			} else {
				puttasktray = 1
			}
		} else : if ev & 128 {
			dialog "Mulanchaを終了しますか？", 2
			if stat == 6 :end
		}

		if onestat >= 0 {
			stick ev, 256, 1
			if ev & 256 {
			} else {
				if ( i != onestat )&( i < itemLen )&( onestat < itemLen ) {
					gosub *movedat
					onestat = -2
					reloaddat = 1
					reloaddatbutnotmove = 1
				} else {
					onestat = -2
					if i < itemLen {
						if itemType(i) == "dir" {
							reloaddat = 1
							curdat = itemPath(i)
						} else {
							clickitem = 1
						}
					} else {
						if copymode == 1 {
							; 複写
							argIndex = -1
							editName = copyName
							editPath = copyPath
							editIcon = copyIcon
							editType = copyType
							editIconIndex = copyIconIndex
							editWorkDir = copyWorkDir
							gosub *writedat

							copymode = 0
							reloaddat = 1
							reloaddatbutnotmove = 1
						} else {
							; 新規アイテム作成
							argIndex = -1
							argName = ""
							argPath = ""
							argIcon = "C:\\Windows\\System32\\shell32.dll"
							argType = 1
							argWdir = ""
							editIconIndex = 0
							gosub *itemedit
							reloaddat = 1
						}
					}
				}
			}
		}
	} else : if ( i == -1 ) {
		stick ev, 0, 1
		if ev & 256 {
			if strlen(parentdat) > 0 {
				reloaddat = 1
				curdat = parentdat
			} else {
				gosub *settingedit

				; フォント等の変更のため、編集・設定ダイアログを再作成
				gosub *createEditDialog
				gosub *createSettingDialog
				reloaddat = 1
			}
		} else : if ev & 128 {
			dialog "Mulanchaを終了しますか？", 2
			if stat == 6 :end
		}
	}
	return

*onDropFiles
	hdrop = wParam
	DragQueryFile hdrop, -1, 0, 0

	sdim fname, 260
	repeat 1
		DragQueryFile hdrop, cnt, varptr(fname), 260
	loop

	DragFinish hdrop

	ondstat = 1
	ondfname = fname

	return

;------------------+
; タスクトレイ関係 |
;------------------+
*clicktasktray
	if (ginfo_act < 0)&(lparam == $00000201) {
		dialog "Mulanchaを終了しますか？", 2
		if stat == 6 :end
	}
	return

;-------------------+
; Dat情報の読み込み |
;-------------------+
*getdat
	chdir curdir
	noteload "data\\" + curdat

	databmp = "data\\" + getpath( curdat, 1 ) +".bmp"
	buffer 1, 512, 32, 0
	gsel 1
	setColor iniBGColor
	boxf
	exist databmp
	databmpsize = strsize
	if databmpsize >= 0 {
		picload databmp, 0
	}

	itemLen = 0
	repeat noteinfo(0)
		noteget s, cnt
		if s == "[item]" :itemLen++
		if strmid(s, 0, 7) == "parent=" : parentdat = strmid(s, 7, 1024)
	loop

	sdim itemName, 32, itemLen
	sdim itemDispName, 10, itemLen, 5
	sdim itemPath, 1024, itemLen
	sdim itemIcon, 1024, itemLen
	sdim itemType, 8, itemLen
	sdim itemWorkDir, 1024, itemLen
	dim  itemIconIndex, itemLen

	; アイコン以外を読み込む
	len = -1
	repeat noteinfo(0)
		noteget s, cnt
		t = strmid(s, 0, 5)
		if s == "[item]" :len++
		if t == "name=" :itemName(len) = strmid(s, 5, 32)
		if t == "path=" :itemPath(len) = strmid(s, 5, 1024)
		if t == "icon=" :itemIcon(len) = strmid(s, 5, 1024)
		if t == "type=" :itemType(len) = strmid(s, 5, 8)
		if t == "wdir=" :itemWorkDir(len) = strmid(s, 5, 1024)
		if t == "indx=" :itemIconIndex(len) = int(strmid(s, 5, 16))
	loop

	if databmpsize < 0 {
		; テンポラリbmpがない場合は、icoを読み込む
		len = -1
		repeat noteinfo(0)
			noteget s, cnt
			t = strmid(s, 0, 5)
			if s == "[item]" :len++
			if t == "icon=" {
				; アイコン取得
				drawIcon2Hdc itemIcon(len), 32 * len, 0, itemIconIndex(len)
			}
		loop

		chdir curdir
		bmpsave databmp
	}

	len++
	itemName(len) = ""
	itemPath(len) = ""
	itemType(len) = ""
	itemIconIndex(len) = 0

	repeat len
		cursor = 0 :column = 0 :zenkaku = 0
		dnt = cnt
		repeat strlen(itemName(dnt))
			b = peek(itemName(dnt), cnt)
			if ( zenkaku > 1 ) {
				zenkaku--
			} else {
				if (( 129 <= b )&( b <= 159 ))|(( 224 <= b )&( b <= 252 )) {
					zenkaku = 2
				} else {
					zenkaku = 0
				}
			}
			if ( cursor == 10 )|(( cursor == 9 )&( zenkaku == 2 )) {
				column++ :cursor = 0
			}
			poke itemDispName(dnt, column), cursor, b
			cursor++
		loop
	loop

	gsel 0
	return

*writedat
	chdir curdir
	noteload "data\\" + curdat

	if argIndex == -1 {
		; 新規
		noteadd "[item]", -1, 0
		noteadd "name=" + editName, -1, 0
		noteadd "path=" + editPath, -1, 0
		noteadd "icon=" + editIcon, -1, 0
		noteadd "type=" + getTypeValue(editType), -1, 0
		noteadd "indx=" + editIconIndex, -1, 0
		noteadd "wdir=" + editWorkDir, -1, 0
	} else : if editMode == 1 {
		; 削除
		len = -1
		repeat noteinfo(0)
			noteget s, cnt
			if s == "[item]" :len++
			if len == argIndex {
				do
					notedel cnt
					noteget s, cnt
				until ( s == "[item]" )|( cnt >= noteinfo(0) )
				len++
			}
		loop
	} else {
		; 編集
		len = -1
		writeflag = 0
		repeat noteinfo(0)
			noteget s, cnt
			if s == "[item]" :len++
			if len == argIndex {
				t = strmid(s, 0, 5)
				if t == "name=" {noteadd "name=" + editName, cnt, 1              : writeflag +=  1 }
				if t == "path=" {noteadd "path=" + editPath, cnt, 1              : writeflag +=  2 }
				if t == "icon=" {noteadd "icon=" + editIcon, cnt, 1              : writeflag +=  4 }
				if t == "type=" {noteadd "type=" + getTypeValue(editType), cnt, 1: writeflag +=  8 }
				if t == "indx=" {noteadd "indx=" + editIconIndex, cnt, 1         : writeflag += 16 }
				if t == "wdir=" {noteadd "wdir=" + editWorkDir, cnt, 1           : writeflag += 32 }
				dnt = cnt + 1
			}
		loop
		if (writeflag&1)  == 0 :noteadd "name=" + editName, dnt, 0
		if (writeflag&2)  == 0 :noteadd "path=" + editPath, dnt, 0
		if (writeflag&4)  == 0 :noteadd "icon=" + editIcon, dnt, 0
		if (writeflag&8)  == 0 :noteadd "type=" + getTypeValue(editType), dnt, 0
		if (writeflag&16) == 0 :noteadd "indx=" + editIconIndex, dnt, 0
		if (writeflag&32) == 0 :noteadd "wdir=" + editWorkDir, dnt, 0
	}

	chdir curdir
	notesave "data\\" + curdat

	; 新規サブメニューの場合
	if ( argIndex == -1 )&( copymode == 0 )&( getTypeValue(editType) == "dir" )&( notMakeSubItem == 0 ) {
		s = "parent=" + curdat
		bsave "data\\" + editPath, s, strlen(s)
	}

	; 中間bmpの作成
	gsel 1
	if argIndex == -1 {
		if copymode == 1 {
			; 複写
			pos 32 * itemLen, 0
			gcopy 6, 0, 0, 32, 32
		} else {
			; 新規
			pos 32 * itemLen, 0
			gcopy 3, 76, 136, 32, 32
		}
	} else : if editMode == 1 {
		; 削除
		setColor iniBGColor
		if ( argIndex < 15 ) {
			pos 32 * argIndex, 0
			gcopy 1, 32 * ( argIndex + 1 ), 0, 32 * ( 15 - argIndex ), 32
		}
		boxf 480, 0, 512, 32
	} else {
		; 編集
		setColor iniBGColor
		boxf 32 * argIndex, 0, 32 * ( argIndex + 1 ), 32
		pos 32 * argIndex, 0
		gcopy 3, 76, 136, 32, 32
	}
	bmpsave "data\\" + getpath( curdat, 1 ) + ".bmp"
	if ( argIndex == -1 )&( copymode == 1 ) {
		gsel 0
	} else {
		gsel 3
	}

	return

*movedat
	; 移動は特殊なので別ルーチン
	movea = onestat :moveb = i

	chdir curdir
	noteload "data\\" + curdat

	buffer 5, 32, 32, 0

	len = -1
	dnt2 = -1
	dnt4 = -1
	repeat noteinfo(0)
		noteget s, cnt
		if s == "[item]" {
			len++
			if len == movea :dnt1 = cnt
			if len == ( movea + 1 ) :dnt2 = cnt
			if len == moveb :dnt3 = cnt
			if len == ( moveb + 1 ) :dnt4 = cnt
		}
	loop
	if dnt2 == -1 :dnt2 = noteinfo(0)
	if dnt4 == -1 :dnt4 = noteinfo(0)

	if movea < moveb {
		repeat dnt2 - dnt1
			noteget s, dnt1 + cnt
			noteadd s, dnt4 + cnt
		loop
		repeat dnt2 - dnt1
			notedel dnt2 - cnt - 1
		loop

		gsel 5
		pos 0, 0
		gcopy 1, 32 * movea, 0, 32, 32
		gsel 1
		pos 32 * movea, 0
		gcopy 1, 32 * ( movea + 1 ), 0, 32 * ( moveb - movea ), 32
		pos 32 * moveb, 0
		gcopy 5, 0, 0, 32, 32
	} else {
		suffix = dnt2 - dnt1
		repeat suffix
			noteget s, dnt1 + ( 2 * cnt )
			noteadd s, dnt3 + cnt
		loop
		repeat suffix
			notedel dnt2 + suffix - cnt - 1
		loop

		gsel 5
		pos 0, 0
		gcopy 1, 32 * movea, 0, 32, 32
		gsel 1
		pos 32 * ( moveb + 1 ), 0
		gcopy 1, 32 * moveb, 0, 32 * ( movea - moveb ), 32
		pos 32 * moveb, 0
		gcopy 5, 0, 0, 32, 32
	}

	chdir curdir
	notesave "data\\" + curdat
	gsel 1
	bmpsave "data\\" + getpath( curdat, 1 ) + ".bmp"

	gsel 0

	return



*onclose
	if ginfo_act = 0 :end
	oncstat = 1
	return

stop

#include "mlc2_dialog.hsp"